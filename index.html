<!DOCTYPE html>
<html>
<head>
    <title>Writer's Best Friend</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f3f3f3;
            color: #333;
            font-size: 16px;
            line-height: 1.5;
        }
        
        button {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f8f8;
            border: 1px solid #d0d0d0;
            padding: 8px 16px;
            cursor: pointer;
            margin: 2px;
            font-size: 15px;
            border-radius: 2px;
        }
        
        button:hover {
            background-color: #e8e8e8;
            border-color: #c0c0c0;
        }
        
        button:active {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            background-color: #f0f0f0;
            color: #999;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }
        
        button.primary {
            background-color: #0078d4;
            color: white;
            border-color: #106ebe;
        }
        
        button.primary:hover {
            background-color: #106ebe;
        }
        
        button.danger {
            background-color: #d13438;
            color: white;
            border-color: #a4262c;
        }
        
        button.danger:hover {
            background-color: #a4262c;
        }
        
        input, select, textarea {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            border: 1px solid #d0d0d0;
            padding: 8px 12px;
            width: 100%;
            box-sizing: border-box;
            font-size: 15px;
            line-height: 1.4;
        }
        
        input:focus, select:focus, textarea:focus {
            border-color: #0078d4;
            outline: none;
            box-shadow: 0 0 3px rgba(0, 120, 212, 0.3);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .section {
            border: 1px solid #e0e0e0;
            margin: 15px 0;
            padding: 15px;
            background-color: #fafafa;
            border-radius: 3px;
        }
        
        .error {
            color: #d13438;
            font-size: 12px;
            margin-top: 3px;
            font-weight: 500;
        }
        
        .rule-item {
            border: 1px solid #d0d0d0;
            padding: 12px;
            margin: 8px 0;
            background-color: white;
            border-radius: 3px;
            position: relative;
        }
        
        .file-item {
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #e0e0e0;
            margin: 3px 0;
            border-radius: 2px;
            background-color: white;
            display: flex;
            align-items: center;
        }
        
        .file-item:hover {
            background-color: #f0f0f0;
        }
        
        .file-item.selected {
            background-color: #e3f2fd;
            border-color: #0078d4;
        }
        
        .bullet {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .bullet.pending { background-color: #999; }
        .bullet.processing { background-color: #0078d4; }
        .bullet.processed { background-color: #107c10; }
        .bullet.error { background-color: #d13438; }
        .bullet.selected { background-color: #0078d4; }
        
        pre {
            border: 1px solid #d0d0d0;
            padding: 12px;
            background-color: white;
            overflow: auto;
            max-height: 400px;
            font-size: 12px;
            font-family: 'Consolas', 'Courier New', monospace;
            border-radius: 2px;
        }
        
        h1 {
            color: #323130;
            font-size: 24px;
            font-weight: 600;
            margin: 0 0 8px 0;
        }
        
        h2 {
            color: #323130;
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 12px 0;
        }
        
        h3 {
            color: #323130;
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 8px 0;
        }
        
        label {
            display: block;
            margin: 8px 0 4px 0;
            font-weight: 600;
            color: #323130;
        }
        
        .form-group {
            margin: 12px 0;
        }
        
        .profile-controls {
            background-color: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 12px;
            margin: 10px 0;
            border-radius: 3px;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        
        .file-browser {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 15px;
        }
        
        .tag-suggestions {
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 2px;
            margin-top: 5px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .tag-suggestion {
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .tag-suggestion:hover {
            background-color: #f0f0f0;
        }
        
        .tag-suggestion:last-child {
            border-bottom: none;
        }
        
        .xml-tree {
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 2px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 12px;
        }
        
        .tree-node {
            margin: 2px 0;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .tree-node:hover {
            background-color: #f0f0f0;
        }
        
        .tree-node.selected {
            background-color: #e3f2fd;
            border: 1px solid #0078d4;
        }
        
        .tree-indent {
            display: inline-block;
            width: 16px;
        }
        
        .tree-tag {
            color: #0078d4;
            font-weight: 500;
        }
        
        .tree-path {
            color: #666;
            font-size: 11px;
            margin-left: 8px;
        }
        
        .targeting-mode {
            background-color: #fff9c4;
            border: 1px solid #fadb14;
            padding: 8px;
            border-radius: 3px;
            margin: 8px 0;
        }
        
        @media (max-width: 768px) {
            .two-column, .file-browser, .three-column {
                grid-template-columns: 1fr;
            }
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect, useRef } = React;

        // Load UI text from external files (would be loaded via fetch in production)
        const UI_TEXT = {
            buttons: {
                saveProfile: "Save Profile",
                loadProfile: "Load Profile",
                selectFiles: "Select XML File(s)",
                selectFolder: "Select Folder",
                pasteData: "Paste XML Data",
                addRule: "Add Rule",
                updateRule: "Update Rule",
                cancel: "Cancel",
                edit: "Edit",
                delete: "Delete",
                applyRules: "Apply Rules to All Files",
                processing: "Processing...",
                copyProcessed: "Copy Processed",
                copyFile: "Copy",
                original: "Original",
                modified: "Modified"
            },
            headers: {
                profileManagement: "Profile Management",
                loadXmlFiles: "Load XML Files",
                xmlStructure: "XML Structure",
                defineNewRule: "Define New Update Rule",
                editRule: "Edit Update Rule",
                currentRules: "Current Update Rules",
                loadedFiles: "Loaded Files",
                filePreview: "File Preview",
                processingResults: "Processing & Results"
            },
            labels: {
                profileName: "Profile Name (optional)",
                targetTag: "Target Tag Name or Path",
                conditionLogic: "Condition Logic",
                conditionValue: "Condition Value",
                conditionValueRegex: "Condition Value (Regex)",
                actionLogic: "Action Logic",
                searchRegex: "Search Regex (for replacement)",
                newContent: "New Content Value",
                replacementValue: "Replacement Value (can use $1, $2 etc.)"
            },
            placeholders: {
                profileName: "My XML Rules",
                targetTag: "e.g., 'title', 'data*', or 'task/equipment/status'",
                regexPattern: "Enter Regex pattern",
                textValue: "Enter text value",
                searchRegex: "Regex to find text, e.g., 'old_text(\\d+)'",
                newContent: "Enter new content",
                replacementValue: "e.g., 'new_text$1'"
            },
            alerts: {
                noRulesToSave: "No rules to save. Please create some rules first.",
                invalidProfile: "Invalid profile format.",
                profileLoaded: (name, count) => `Profile "${name}" loaded successfully with ${count} rules.`,
                errorLoadingProfile: (error) => `Error loading profile: ${error}`,
                noFilesOrRules: "Please load XML files and define at least one update rule.",
                fileNotProcessed: "File has not been processed or processing resulted in an error.",
                noProcessedFiles: "No files were successfully processed to download.",
                xmlReadError: "Some XML files could not be read. Please check console for errors.",
                noXmlFound: "No XML files found in selection."
            },
            status: {
                viewing: (filename) => `Viewing: ${filename}`,
                ruleCount: (count) => `(${count})`,
                fileCount: (count) => `(${count})`,
                selectedPath: (path) => `Selected path: ${path} - Click "Add Rule" to use this target.`,
                noChanges: "No changes applied to this file based on current rules."
            }
        };

        // Types and Enums
        const ConditionLogic = {
            ALWAYS_APPLY: "Always Apply",
            CONTENT_EQUALS: "Content Equals",
            CONTENT_CONTAINS: "Content Contains",
            CONTENT_MATCHES_REGEX: "Content Matches Regex (on tag's text content)",
        };

        const ActionLogic = {
            REPLACE_ENTIRE_CONTENT: "Replace Entire Content with Text",
            REGEX_REPLACE_IN_CONTENT: "Regex Replace in Content",
            REMOVE_TAG: "Remove Tag",
        };

        // Enhanced XML Structure Analysis
        const analyzeXmlStructure = (xmlString) => {
            const structure = [];
            const tagPaths = new Set();
            
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlString, "application/xml");
                
                const parsingError = doc.getElementsByTagName("parsererror");
                if (parsingError.length > 0) {
                    return { structure: [], tagPaths: [] };
                }

                const buildPath = (element, path = []) => {
                    const currentPath = [...path, element.tagName];
                    const pathString = currentPath.join('/');
                    tagPaths.add(pathString);
                    
                    structure.push({
                        tag: element.tagName,
                        path: pathString,
                        depth: currentPath.length - 1,
                        hasChildren: element.children.length > 0,
                        textContent: element.children.length === 0 ? (element.textContent || '').trim() : ''
                    });

                    Array.from(element.children).forEach(child => {
                        buildPath(child, currentPath);
                    });
                };

                if (doc.documentElement) {
                    buildPath(doc.documentElement);
                }
            } catch (e) {
                console.error("Error analyzing XML structure:", e);
            }
            
            return { 
                structure, 
                tagPaths: Array.from(tagPaths).sort() 
            };
        };

        // Enhanced XML Processing with XPath-like targeting
        const applyRulesToXmlWithPath = (xmlString, rules) => {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlString, "application/xml");
                const serializer = new XMLSerializer();

                const parsingError = doc.getElementsByTagName("parsererror");
                if (parsingError.length > 0) {
                    const errorText = parsingError[0]?.textContent || "Unknown parsing error";
                    console.error("XML Parsing Error:", errorText);
                    return { updatedXml: xmlString, error: `Invalid XML: ${errorText.substring(0,100)}...` };
                }

                let modified = false;

                rules.forEach(rule => {
                    const elementsToProcess = [];
                    
                    if (rule.targetTag.includes('/')) {
                        const pathParts = rule.targetTag.split('/');
                        let currentElements = [doc.documentElement];
                        
                        pathParts.forEach(part => {
                            const nextElements = [];
                            currentElements.forEach(element => {
                                if (part.includes('*') || part.includes('?')) {
                                    const regexPattern = part
                                        .replace(/[.+^${}()|[\]\\]/g, '\\$&')
                                        .replace(/\*/g, '.*')
                                        .replace(/\?/g, '.');
                                    const tagRegex = new RegExp(`^${regexPattern}$`, 'i');
                                    
                                    Array.from(element.children).forEach(child => {
                                        if (tagRegex.test(child.tagName)) {
                                            nextElements.push(child);
                                        }
                                    });
                                } else {
                                    Array.from(element.children).forEach(child => {
                                        if (child.tagName === part) {
                                            nextElements.push(child);
                                        }
                                    });
                                }
                            });
                            currentElements = nextElements;
                        });
                        
                        elementsToProcess.push(...currentElements);
                    } 
                    else if (rule.targetTag.includes('*') || rule.targetTag.includes('?')) {
                        const regexPattern = rule.targetTag
                            .replace(/[.+^${}()|[\]\\]/g, '\\$&')
                            .replace(/\*/g, '.*')
                            .replace(/\?/g, '.');
                        const tagRegex = new RegExp(`^${regexPattern}$`, 'i');
                        
                        const allElements = doc.getElementsByTagName('*');
                        for (let i = 0; i < allElements.length; i++) {
                            if (tagRegex.test(allElements[i].tagName)) {
                                elementsToProcess.push(allElements[i]);
                            }
                        }
                    } 
                    else {
                        const foundElements = doc.getElementsByTagName(rule.targetTag);
                        for (let i = 0; i < foundElements.length; i++) {
                            elementsToProcess.push(foundElements[i]);
                        }
                    }

                    elementsToProcess.forEach(element => {
                        let conditionMet = false;
                        const currentContent = element.textContent || "";

                        switch (rule.conditionLogic) {
                            case ConditionLogic.ALWAYS_APPLY:
                                conditionMet = true;
                                break;
                            case ConditionLogic.CONTENT_EQUALS:
                                conditionMet = currentContent === rule.conditionValue;
                                break;
                            case ConditionLogic.CONTENT_CONTAINS:
                                conditionMet = currentContent.includes(rule.conditionValue);
                                break;
                            case ConditionLogic.CONTENT_MATCHES_REGEX:
                                try {
                                    const regex = new RegExp(rule.conditionValue);
                                    conditionMet = regex.test(currentContent);
                                } catch (e) {
                                    console.error("Invalid regex in condition: ", rule.conditionValue, e);
                                }
                                break;
                        }

                        if (conditionMet) {
                            modified = true;
                            switch (rule.actionLogic) {
                                case ActionLogic.REPLACE_ENTIRE_CONTENT:
                                    element.textContent = rule.actionValue;
                                    break;
                                case ActionLogic.REGEX_REPLACE_IN_CONTENT:
                                    if (rule.actionSearchRegex) {
                                        try {
                                            const findRegex = new RegExp(rule.actionSearchRegex, 'g');
                                            element.textContent = currentContent.replace(findRegex, rule.actionValue);
                                        } catch (e) {
                                            console.error("Invalid regex for search/replace: ", rule.actionSearchRegex, e);
                                        }
                                    }
                                    break;
                                case ActionLogic.REMOVE_TAG:
                                    element.parentNode?.removeChild(element);
                                    break;
                            }
                        }
                    });
                });
                
                return { updatedXml: serializer.serializeToString(doc) };

            } catch (e) {
                console.error("Error applying rules to XML:", e);
                return { updatedXml: xmlString, error: e.message || "Unknown error during processing." };
            }
        };

        // Profile Management Functions
        const saveProfile = (rules, profileName) => {
            const profile = {
                name: profileName || `Profile_${new Date().toISOString().split('T')[0]}`,
                rules: rules,
                created: new Date().toISOString(),
                version: "1.0"
            };
            
            const blob = new Blob([JSON.stringify(profile, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${profile.name}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        const loadProfile = (file, onRulesLoaded) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const profile = JSON.parse(e.target.result);
                    if (profile.rules && Array.isArray(profile.rules)) {
                        onRulesLoaded(profile.rules);
                        alert(UI_TEXT.alerts.profileLoaded(profile.name, profile.rules.length));
                    } else {
                        alert(UI_TEXT.alerts.invalidProfile);
                    }
                } catch (error) {
                    alert(UI_TEXT.alerts.errorLoadingProfile(error.message));
                }
            };
            reader.readAsText(file);
        };

        // Auto-save to localStorage
        const autoSaveRules = (rules) => {
            try {
                localStorage.setItem('writers_best_friend_rules', JSON.stringify(rules));
            } catch (e) {
                console.warn("Could not save to localStorage:", e);
            }
        };

        const loadAutoSavedRules = () => {
            try {
                const saved = localStorage.getItem('writers_best_friend_rules');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.warn("Could not load from localStorage:", e);
                return [];
            }
        };

        // Components
        const XmlStructureViewer = ({ files, onPathSelect, selectedPath }) => {
            const [xmlStructure, setXmlStructure] = useState([]);
            const [tagPaths, setTagPaths] = useState([]);
            
            useEffect(() => {
                if (files.length > 0) {
                    const { structure, tagPaths: paths } = analyzeXmlStructure(files[0].originalContent);
                    setXmlStructure(structure);
                    setTagPaths(paths);
                }
            }, [files]);

            if (files.length === 0) {
                return (
                    <div className="section">
                        <h3>{UI_TEXT.headers.xmlStructure}</h3>
                    </div>
                );
            }

            return (
                <div className="section">
                    <h3>{UI_TEXT.headers.xmlStructure}</h3>
                    <div className="xml-tree">
                        {xmlStructure.map((node, index) => (
                            <div
                                key={index}
                                className={`tree-node ${selectedPath === node.path ? 'selected' : ''}`}
                                onClick={() => onPathSelect(node.path)}
                            >
                                <span className="tree-indent" style={{width: `${node.depth * 16}px`}}></span>
                                <span className="tree-tag">&lt;{node.tag}&gt;</span>
                                {node.textContent && (
                                    <span style={{color: '#666', fontSize: '11px'}}> "{node.textContent.substring(0, 30)}{node.textContent.length > 30 ? '...' : ''}"</span>
                                )}
                                <span className="tree-path">{node.path}</span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const ProfileManager = ({ rules, onRulesLoaded }) => {
            const [profileName, setProfileName] = useState('');
            const fileInputRef = useRef(null);

            const handleSaveProfile = () => {
                if (rules.length === 0) {
                    alert(UI_TEXT.alerts.noRulesToSave);
                    return;
                }
                saveProfile(rules, profileName || undefined);
                setProfileName('');
            };

            const handleLoadProfile = (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadProfile(file, onRulesLoaded);
                }
                event.target.value = '';
            };

            return (
                <div className="profile-controls">
                    <h3>{UI_TEXT.headers.profileManagement}</h3>
                    <div style={{display: 'flex', gap: '10px', alignItems: 'end', flexWrap: 'wrap'}}>
                        <div style={{flex: '1', minWidth: '200px'}}>
                            <label>{UI_TEXT.labels.profileName}</label>
                            <input
                                type="text"
                                value={profileName}
                                onChange={(e) => setProfileName(e.target.value)}
                                placeholder={UI_TEXT.placeholders.profileName}
                            />
                        </div>
                        <button onClick={handleSaveProfile} className="primary">
                            {UI_TEXT.buttons.saveProfile}
                        </button>
                        <button onClick={() => fileInputRef.current?.click()}>
                            {UI_TEXT.buttons.loadProfile}
                        </button>
                        <input
                            type="file"
                            ref={fileInputRef}
                            accept=".json"
                            onChange={handleLoadProfile}
                            style={{display: 'none'}}
                        />
                    </div>
                </div>
            );
        };

        const FileSelector = ({ onFilesSelected, isLoading }) => {
            const fileInputRef = useRef(null);
            const folderInputRef = useRef(null);
            const [pastedData, setPastedData] = useState('');
            const [showPasteArea, setShowPasteArea] = useState(false);

            const handleFileProcessing = useCallback(async (selectedFiles) => {
                if (!selectedFiles || selectedFiles.length === 0) return;

                const xmlFilesPromises = Array.from(selectedFiles)
                    .filter(file => file.name.toLowerCase().endsWith('.xml'))
                    .map(file => {
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                if (e.target?.result) {
                                    resolve({
                                        id: crypto.randomUUID(),
                                        name: file.name,
                                        originalContent: e.target.result,
                                        modifiedContent: null,
                                        status: 'pending',
                                    });
                                } else {
                                    resolve(null);
                                }
                            };
                            reader.onerror = (e) => {
                                console.error("File reading error:", file.name, e);
                                resolve(null);
                            };
                            reader.readAsText(file);
                        });
                    });

                const loadedFiles = (await Promise.all(xmlFilesPromises)).filter(f => f !== null);
                if (loadedFiles.length > 0) {
                    onFilesSelected(loadedFiles);
                } else if (Array.from(selectedFiles).some(f => f.name.toLowerCase().endsWith('.xml'))) {
                    alert(UI_TEXT.alerts.xmlReadError);
                } else if (selectedFiles.length > 0) {
                    alert(UI_TEXT.alerts.noXmlFound);
                }
            }, [onFilesSelected]);

            const handleFileChange = (event) => {
                handleFileProcessing(event.target.files);
                if (event.target) event.target.value = '';
            };

            const openFileDialog = () => fileInputRef.current?.click();
            const openFolderDialog = () => folderInputRef.current?.click();

            const handlePasteData = () => {
                if (!pastedData.trim()) {
                    alert("Please paste XML data first.");
                    return;
                }
                
                const xmlFile = {
                    id: crypto.randomUUID(),
                    name: `Pasted_Data_${new Date().toISOString().split('T')[0]}.xml`,
                    originalContent: pastedData,
                    modifiedContent: null,
                    status: 'pending',
                };
                
                onFilesSelected([xmlFile]);
                setPastedData('');
                setShowPasteArea(false);
            };

            return (
                <div className="section">
                    <h2>{UI_TEXT.headers.loadXmlFiles}</h2>
                    <div style={{display: 'flex', gap: '10px', flexWrap: 'wrap', marginBottom: '15px'}}>
                        <button onClick={openFileDialog} disabled={isLoading} className="primary">
                            {UI_TEXT.buttons.selectFiles}
                        </button>
                        <button onClick={openFolderDialog} disabled={isLoading}>
                            {UI_TEXT.buttons.selectFolder}
                        </button>
                        <button onClick={() => setShowPasteArea(!showPasteArea)} disabled={isLoading}>
                            {UI_TEXT.buttons.pasteData}
                        </button>
                        <input
                            type="file"
                            ref={fileInputRef}
                            multiple
                            accept=".xml,application/xml,text/xml"
                            onChange={handleFileChange}
                            style={{display: 'none'}}
                        />
                        <input
                            type="file"
                            ref={folderInputRef}
                            webkitdirectory=""
                            directory=""
                            multiple
                            onChange={handleFileChange}
                            style={{display: 'none'}}
                        />
                    </div>
                    {showPasteArea && (
                        <div style={{marginBottom: '15px'}}>
                            <textarea
                                value={pastedData}
                                onChange={(e) => setPastedData(e.target.value)}
                                placeholder="Paste your XML data here..."
                                rows={8}
                                style={{width: '100%', fontFamily: 'monospace', fontSize: '14px'}}
                            />
                            <div style={{marginTop: '10px', display: 'flex', gap: '10px'}}>
                                <button onClick={handlePasteData} className="primary" disabled={!pastedData.trim()}>
                                    Load Pasted Data
                                </button>
                                <button onClick={() => {setPastedData(''); setShowPasteArea(false);}}>
                                    Cancel
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const TagSuggestions = ({ tags, onTagSelect, visible }) => {
            if (!visible || tags.length === 0) return null;

            return (
                <div className="tag-suggestions">
                    {tags.map(tag => (
                        <div
                            key={tag}
                            className="tag-suggestion"
                            onClick={() => onTagSelect(tag)}
                        >
                            {tag}
                        </div>
                    ))}
                </div>
            );
        };

        const RuleEditor = ({ onAddRule, existingRule, onUpdateRule, onCancelEdit, discoveredTags, tagPaths, selectedPath, onPathSelect }) => {
            const initialRuleState = {
                targetTag: '',
                conditionLogic: ConditionLogic.ALWAYS_APPLY,
                conditionValue: '',
                actionLogic: ActionLogic.REPLACE_ENTIRE_CONTENT,
                actionValue: '',
                actionSearchRegex: '',
            };

            const [rule, setRule] = useState(existingRule || initialRuleState);
            const [errors, setErrors] = useState({});
            const [showTagSuggestions, setShowTagSuggestions] = useState(false);

            const conditionLogicOptions = Object.values(ConditionLogic).map(val => ({ value: val, label: val }));
            const actionLogicOptions = Object.values(ActionLogic).map(val => ({ value: val, label: val }));

            useEffect(() => {
                if (existingRule) {
                    setRule(existingRule);
                    setErrors({});
                } else {
                    setRule(initialRuleState);
                    setErrors({});
                }
            }, [existingRule]);

            useEffect(() => {
                if (selectedPath) {
                    handleInputChange('targetTag', selectedPath);
                    onPathSelect(null);
                }
            }, [selectedPath]);

            const validateRule = () => {
                const newErrors = {};
                if (!rule.targetTag.trim()) newErrors.targetTag = "Target tag is required.";
                
                if (rule.conditionLogic !== ConditionLogic.ALWAYS_APPLY && !rule.conditionValue.trim()) {
                    newErrors.conditionValue = "Condition value is required for the selected logic.";
                }
                if (rule.conditionLogic === ConditionLogic.CONTENT_MATCHES_REGEX && rule.conditionValue) {
                    try { new RegExp(rule.conditionValue); } 
                    catch (e) { newErrors.conditionValue = "Invalid Regex pattern for condition."; }
                }

                if (rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT) {
                    if (!rule.actionSearchRegex?.trim()) newErrors.actionSearchRegex = "Search Regex is required for this action.";
                    else {
                        try { new RegExp(rule.actionSearchRegex); }
                        catch (e) { newErrors.actionSearchRegex = "Invalid Regex pattern for search."; }
                    }
                }
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };

            const handleSubmit = (event) => {
                event.preventDefault();
                if (!validateRule()) return;
                
                const finalRule = { ...rule, id: existingRule?.id || crypto.randomUUID() };

                if (existingRule && onUpdateRule) {
                    onUpdateRule(finalRule);
                } else {
                    onAddRule(finalRule);
                    setRule(initialRuleState);
                    setErrors({});
                }
            };

            const handleInputChange = (field, value) => {
                setRule(prev => ({ ...prev, [field]: value }));
                if (errors[field]) {
                    setErrors(prev => ({ ...prev, [field]: undefined }));
                }
            };

            const handleTagSelect = (tag) => {
                handleInputChange('targetTag', tag);
                setShowTagSuggestions(false);
            };

            const allSuggestions = [...new Set([...discoveredTags, ...tagPaths])].sort();
            
            return (
                <form onSubmit={handleSubmit} className="section">
                    <h2>{existingRule ? UI_TEXT.headers.editRule : UI_TEXT.headers.defineNewRule}</h2>
                    
                    {selectedPath && (
                        <div className="targeting-mode">
                            <strong>{UI_TEXT.status.selectedPath(selectedPath)}</strong>
                        </div>
                    )}
                    
                    <div className="form-group">
                        <label htmlFor="targetTag">{UI_TEXT.labels.targetTag}</label>
                        <input
                            type="text"
                            id="targetTag"
                            value={rule.targetTag}
                            onChange={(e) => handleInputChange('targetTag', e.target.value)}
                            onFocus={() => setShowTagSuggestions(true)}
                            onBlur={() => setTimeout(() => setShowTagSuggestions(false), 200)}
                            placeholder={UI_TEXT.placeholders.targetTag}
                        />
                        <TagSuggestions 
                            tags={allSuggestions} 
                            onTagSelect={handleTagSelect}
                            visible={showTagSuggestions && allSuggestions.length > 0}
                        />
                        {errors.targetTag && <div className="error">{errors.targetTag}</div>}
                    </div>

                    <div className="two-column">
                        <div className="form-group">
                            <label htmlFor="conditionLogic">{UI_TEXT.labels.conditionLogic}</label>
                            <select
                                id="conditionLogic"
                                value={rule.conditionLogic}
                                onChange={(e) => handleInputChange('conditionLogic', e.target.value)}
                            >
                                {conditionLogicOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                            </select>
                        </div>
                        {rule.conditionLogic !== ConditionLogic.ALWAYS_APPLY && (
                            <div className="form-group">
                                <label htmlFor="conditionValue">
                                    {UI_TEXT.labels.conditionValue} {rule.conditionLogic === ConditionLogic.CONTENT_MATCHES_REGEX && "(Regex)"}
                                </label>
                                <input
                                    type="text"
                                    id="conditionValue"
                                    value={rule.conditionValue}
                                    onChange={(e) => handleInputChange('conditionValue', e.target.value)}
                                    placeholder={
                                        rule.conditionLogic === ConditionLogic.CONTENT_MATCHES_REGEX ? UI_TEXT.placeholders.regexPattern : UI_TEXT.placeholders.textValue
                                    }
                                />
                                {errors.conditionValue && <div className="error">{errors.conditionValue}</div>}
                            </div>
                        )}
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="actionLogic">{UI_TEXT.labels.actionLogic}</label>
                        <select
                            id="actionLogic"
                            value={rule.actionLogic}
                            onChange={(e) => {
                                const newActionLogic = e.target.value;
                                handleInputChange('actionLogic', newActionLogic);
                                if (newActionLogic !== ActionLogic.REGEX_REPLACE_IN_CONTENT) {
                                    handleInputChange('actionSearchRegex', '');
                                }
                            }}
                        >
                            {actionLogicOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                        </select>
                    </div>

                    {rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT && (
                        <div className="form-group">
                            <label htmlFor="actionSearchRegex">{UI_TEXT.labels.searchRegex}</label>
                            <input
                                type="text"
                                id="actionSearchRegex"
                                value={rule.actionSearchRegex || ''}
                                onChange={(e) => handleInputChange('actionSearchRegex', e.target.value)}
                                placeholder={UI_TEXT.placeholders.searchRegex}
                            />
                            {errors.actionSearchRegex && <div className="error">{errors.actionSearchRegex}</div>}
                        </div>
                    )}

                    {rule.actionLogic !== ActionLogic.REMOVE_TAG && (
                        <div className="form-group">
                            <label htmlFor="actionValue">
                                {rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT ? UI_TEXT.labels.replacementValue : UI_TEXT.labels.newContent}
                            </label>
                            <textarea
                                id="actionValue"
                                value={rule.actionValue}
                                onChange={(e) => handleInputChange('actionValue', e.target.value)}
                                rows={3}
                                placeholder={
                                    rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT ? UI_TEXT.placeholders.replacementValue : UI_TEXT.placeholders.newContent
                                }
                            />
                        </div>
                    )}

                    <div style={{marginTop: '15px', display: 'flex', gap: '8px'}}>
                        {existingRule && onCancelEdit && (
                            <button type="button" onClick={() => {
                                onCancelEdit();
                                setRule(initialRuleState);
                                setErrors({});
                            }}>
                                {UI_TEXT.buttons.cancel}
                            </button>
                        )}
                        <button type="submit" className="primary">
                            {existingRule ? UI_TEXT.buttons.updateRule : UI_TEXT.buttons.addRule}
                        </button>
                    </div>
                </form>
            );
        };

        const RuleList = ({ rules, onDeleteRule, onEditRule }) => {
            if (rules.length === 0) {
                return (
                    <div className="section">
                        <h2>{UI_TEXT.headers.currentRules}</h2>
                    </div>
                );
            }

            return (
                <div className="section">
                    <h2>{UI_TEXT.headers.currentRules} {UI_TEXT.status.ruleCount(rules.length)}</h2>
                    <div style={{maxHeight: '400px', overflow: 'auto'}}>
                        {rules.map((rule, index) => (
                            <div key={rule.id} className="rule-item">
                                <div style={{display: 'flex', alignItems: 'flex-start'}}>
                                    <div className="bullet selected"></div>
                                    <div style={{flex: 1}}>
                                        <div style={{fontWeight: '600', marginBottom: '6px'}}>
                                            Rule #{index + 1}: Target {rule.targetTag.includes('/') ? `path "${rule.targetTag}"` : `<${rule.targetTag}>`}
                                        </div>
                                        <div style={{fontSize: '12px', marginBottom: '4px', color: '#666'}}>
                                            <strong>Condition:</strong> {rule.conditionLogic} 
                                            {rule.conditionLogic !== 'Always Apply' && rule.conditionValue && 
                                                <span> "{rule.conditionValue.length > 30 ? rule.conditionValue.substring(0,27)+'...' : rule.conditionValue}"</span>}
                                        </div>
                                        <div style={{fontSize: '12px', color: '#666'}}>
                                            <strong>Action:</strong> {rule.actionLogic}
                                            {rule.actionLogic !== 'Remove Tag' && 
                                                <span> "{rule.actionValue.length > 30 ? rule.actionValue.substring(0,27)+'...' : rule.actionValue}"</span>}
                                            {rule.actionLogic === 'Regex Replace in Content' && rule.actionSearchRegex && 
                                                <span> (Find: "{rule.actionSearchRegex.length > 20 ? rule.actionSearchRegex.substring(0,17)+'...' : rule.actionSearchRegex}")</span>}
                                        </div>
                                    </div>
                                    <div style={{display: 'flex', gap: '4px', marginLeft: '8px'}}>
                                        <button onClick={() => onEditRule(rule)} style={{fontSize: '11px', padding: '4px 8px'}}>
                                            {UI_TEXT.buttons.edit}
                                        </button>
                                        <button onClick={() => onDeleteRule(rule.id)} className="danger" style={{fontSize: '11px', padding: '4px 8px'}}>
                                            {UI_TEXT.buttons.delete}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const XmlFileView = ({ files, onFileSelect, selectedFileId, onCopyFile }) => {
            const [showOriginal, setShowOriginal] = useState(true);
            const selectedFile = files.find(f => f.id === selectedFileId);

            useEffect(() => {
                if (!selectedFileId || (selectedFile && !selectedFile.modifiedContent)) {
                    setShowOriginal(true);
                }
            }, [selectedFileId, selectedFile]);

            if (files.length === 0) {
                return (
                    <div className="section">
                        <h3>{UI_TEXT.headers.filePreview}</h3>
                    </div>
                );
            }

            return (
                <div className="file-browser">
                    <div className="section">
                        <h3>{UI_TEXT.headers.loadedFiles} {UI_TEXT.status.fileCount(files.length)}</h3>
                        <div style={{maxHeight: '400px', overflow: 'auto'}}>
                            {files.map(file => (
                                <div key={file.id}>
                                    <div
                                        className={`file-item ${selectedFileId === file.id ? 'selected' : ''}`}
                                        style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}
                                    >
                                        <div 
                                            onClick={() => onFileSelect(file.id)}
                                            style={{display: 'flex', alignItems: 'center', flex: 1, cursor: 'pointer'}}
                                        >
                                            <div className={`bullet ${selectedFileId === file.id ? 'selected' : file.status}`}></div>
                                            <span style={{overflow: 'hidden', textOverflow: 'ellipsis', fontSize: '15px'}}>{file.name}</span>
                                        </div>
                                        {file.status === 'processed' && file.modifiedContent && !file.error && (
                                            <button 
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    onCopyFile(file);
                                                }}
                                                style={{fontSize: '12px', padding: '4px 8px', marginLeft: '8px'}}
                                            >
                                                {UI_TEXT.buttons.copyFile}
                                            </button>
                                        )}
                                    </div>
                                    {file.status === 'error' && file.error && (
                                        <div className="error" style={{marginLeft: '20px', fontSize: '12px'}}>{file.error}</div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="section">
                        <h3>{UI_TEXT.headers.filePreview}</h3>
                        {selectedFile ? (
                            <div>
                                <div style={{marginBottom: '12px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '8px'}}>
                                    <span style={{fontWeight: '600'}}>{UI_TEXT.status.viewing(selectedFile.name)}</span>
                                    {selectedFile.modifiedContent && selectedFile.status === 'processed' && (
                                        <div style={{display: 'flex', gap: '4px'}}>
                                            <button
                                                onClick={() => setShowOriginal(true)}
                                                className={showOriginal ? 'primary' : ''}
                                                style={{fontSize: '12px', padding: '4px 8px'}}
                                            >
                                                {UI_TEXT.buttons.original}
                                            </button>
                                            <button
                                                onClick={() => setShowOriginal(false)}
                                                className={!showOriginal ? 'primary' : ''}
                                                style={{fontSize: '12px', padding: '4px 8px'}}
                                            >
                                                {UI_TEXT.buttons.modified}
                                            </button>
                                        </div>
                                    )}
                                </div>
                                <pre>
                                    {showOriginal || !selectedFile.modifiedContent ? selectedFile.originalContent : selectedFile.modifiedContent}
                                </pre>
                                {selectedFile.status === 'error' && selectedFile.error && (
                                    <div className="error" style={{marginTop: '8px', padding: '8px', backgroundColor: '#fff2f0', border: '1px solid #ffccc7'}}>{selectedFile.error}</div>
                                )}
                                {selectedFile.status === 'processed' && !selectedFile.error && selectedFile.modifiedContent === selectedFile.originalContent && (
                                    <div style={{padding: '8px', backgroundColor: '#fffbe6', border: '1px solid #ffe58f', marginTop: '8px', fontSize: '12px'}}>
                                        {UI_TEXT.status.noChanges}
                                    </div>
                                )}
                            </div>
                        ) : (
                            <p></p>
                        )}
                    </div>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [files, setFiles] = useState([]);
            const [rules, setRules] = useState(() => loadAutoSavedRules());
            const [editingRule, setEditingRule] = useState(null);
            const [selectedFileId, setSelectedFileId] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [discoveredTags, setDiscoveredTags] = useState([]);
            const [tagPaths, setTagPaths] = useState([]);
            const [selectedPath, setSelectedPath] = useState(null);

            useEffect(() => {
                autoSaveRules(rules);
            }, [rules]);

            const handleFilesSelected = useCallback((newFiles) => {
                setFiles(prevFiles => {
                    const existingFileNames = new Set(prevFiles.map(f => f.name));
                    const uniqueNewFiles = newFiles.filter(nf => !existingFileNames.has(nf.name));
                    const updatedFiles = [...prevFiles, ...uniqueNewFiles];
                    
                    const newTags = new Set(discoveredTags);
                    const newPaths = new Set(tagPaths);
                    
                    uniqueNewFiles.forEach(file => {
                        const { structure, tagPaths: paths } = analyzeXmlStructure(file.originalContent);
                        structure.forEach(node => newTags.add(node.tag));
                        paths.forEach(path => newPaths.add(path));
                    });
                    
                    setDiscoveredTags(Array.from(newTags).sort());
                    setTagPaths(Array.from(newPaths).sort());

                    return updatedFiles;
                });
                if (newFiles.length > 0 && !selectedFileId) {
                    setSelectedFileId(newFiles[0].id);
                }
            }, [selectedFileId, discoveredTags, tagPaths]);

            const handleAddRule = useCallback((newRule) => {
                setRules(prevRules => [...prevRules, newRule]);
            }, []);

            const handleUpdateRule = useCallback((updatedRule) => {
                setRules(prevRules => prevRules.map(r => r.id === updatedRule.id ? updatedRule : r));
                setEditingRule(null);
            }, []);

            const handleDeleteRule = useCallback((ruleId) => {
                setRules(prevRules => prevRules.filter(rule => rule.id !== ruleId));
                if (editingRule?.id === ruleId) setEditingRule(null);
            }, [editingRule]);

            const handleEditRule = (rule) => {
                setEditingRule(rule);
            };
            
            const handleCancelEditRule = () => {
                setEditingRule(null);
            };

            const handleRulesLoaded = (loadedRules) => {
                setRules(loadedRules);
                setEditingRule(null);
            };

            const processFiles = useCallback(async () => {
                if (files.length === 0 || rules.length === 0) {
                    alert(UI_TEXT.alerts.noFilesOrRules);
                    return;
                }
                setIsLoading(true);
                
                setFiles(prevFiles => prevFiles.map(f => ({ ...f, status: 'processing', error: null, modifiedContent: null })));

                const updatedFilesPromises = files.map(async (file) => {
                    await new Promise(resolve => setTimeout(resolve, 10)); 
                    const { updatedXml, error } = applyRulesToXmlWithPath(file.originalContent, rules);
                    return {
                        ...file,
                        modifiedContent: error ? file.originalContent : updatedXml,
                        status: error ? 'error' : 'processed',
                        error: error || null,
                    };
                });

                const processedFiles = await Promise.all(updatedFilesPromises);
                setFiles(processedFiles);
                setIsLoading(false);
            }, [files, rules]);

            const copyToClipboard = async (text) => {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch (err) {
                    console.error('Failed to copy: ', err);
                    return false;
                }
            };

            const copyFile = async (file) => {
                if (!file.modifiedContent) {
                    alert(UI_TEXT.alerts.fileNotProcessed);
                    return;
                }
                
                const success = await copyToClipboard(file.modifiedContent);
                if (success) {
                    alert(`Copied ${file.name} to clipboard!`);
                } else {
                    alert("Failed to copy to clipboard. Please try again.");
                }
            };
            
            const copyAllProcessedFiles = async () => {
                const successfullyProcessedFiles = files.filter(f => f.status === 'processed' && f.modifiedContent && !f.error);
                if (successfullyProcessedFiles.length === 0) {
                    alert(UI_TEXT.alerts.noProcessedFiles);
                    return;
                }
                
                const allContent = successfullyProcessedFiles.map(file => 
                    `<!-- ${file.name} -->\n${file.modifiedContent}`
                ).join('\n\n');
                
                const success = await copyToClipboard(allContent);
                if (success) {
                    alert(`Copied ${successfullyProcessedFiles.length} processed files to clipboard!`);
                } else {
                    alert("Failed to copy to clipboard. Please try again.");
                }
            };

            return (
                <div className="container">
                    <ProfileManager rules={rules} onRulesLoaded={handleRulesLoaded} />

                    <FileSelector onFilesSelected={handleFilesSelected} isLoading={isLoading} />

                    <div className="three-column">
                        <XmlStructureViewer 
                            files={files} 
                            onPathSelect={setSelectedPath}
                            selectedPath={selectedPath}
                        />
                        <RuleEditor 
                            onAddRule={handleAddRule} 
                            existingRule={editingRule}
                            onUpdateRule={handleUpdateRule}
                            onCancelEdit={handleCancelEditRule}
                            discoveredTags={discoveredTags}
                            tagPaths={tagPaths}
                            selectedPath={selectedPath}
                            onPathSelect={setSelectedPath}
                        />
                        <RuleList rules={rules} onDeleteRule={handleDeleteRule} onEditRule={handleEditRule} />
                    </div>
                    
                    {files.length > 0 && (
                        <div className="section">
                            <div style={{marginBottom: '15px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '10px'}}>
                                <h2>{UI_TEXT.headers.processingResults}</h2>
                                <div style={{display: 'flex', gap: '8px'}}>
                                    <button
                                        onClick={processFiles}
                                        disabled={isLoading || files.length === 0 || rules.length === 0}
                                        className="primary"
                                    >
                                        {isLoading ? UI_TEXT.buttons.processing : UI_TEXT.buttons.applyRules}
                                    </button>
                                    <button
                                        onClick={copyAllProcessedFiles}
                                        disabled={isLoading || files.filter(f => f.status === 'processed' && !f.error).length === 0}
                                    >
                                        {UI_TEXT.buttons.copyProcessed}
                                    </button>
                                </div>
                            </div>
                            <XmlFileView files={files} onFileSelect={setSelectedFileId} selectedFileId={selectedFileId} onCopyFile={copyFile} />
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>