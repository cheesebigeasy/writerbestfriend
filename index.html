<!DOCTYPE html>
<html>
<head>
    <title>Writer's Best Friend</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f3f3f3;
            color: #333;
            font-size: 16px;
            line-height: 1.5;
        }
        
        button {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f8f8;
            border: 1px solid #d0d0d0;
            padding: 8px 16px;
            cursor: pointer;
            margin: 2px;
            font-size: 15px;
            border-radius: 2px;
        }
        
        button:hover {
            background-color: #e8e8e8;
            border-color: #c0c0c0;
        }
        
        button:active {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            background-color: #f0f0f0;
            color: #999;
            cursor: not-allowed;
            border-color: #e0e0e0;
        }
        
        button.primary {
            background-color: #0078d4;
            color: white;
            border-color: #106ebe;
        }
        
        button.primary:hover {
            background-color: #106ebe;
        }
        
        button.danger {
            background-color: #d13438;
            color: white;
            border-color: #a4262c;
        }
        
        button.danger:hover {
            background-color: #a4262c;
        }
        
        input, select, textarea {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            border: 1px solid #d0d0d0;
            padding: 8px 12px;
            width: 100%;
            box-sizing: border-box;
            font-size: 15px;
            line-height: 1.4;
        }
        
        input:focus, select:focus, textarea:focus {
            border-color: #0078d4;
            outline: none;
            box-shadow: 0 0 3px rgba(0, 120, 212, 0.3);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-x: auto;
            box-sizing: border-box;
        }
        
        .section {
            border: 1px solid #e0e0e0;
            margin: 15px 0;
            padding: 15px;
            background-color: #fafafa;
            border-radius: 3px;
        }
        
        .section.collapsed {
            padding-bottom: 5px;
        }
        
        .error {
            color: #d13438;
            font-size: 12px;
            margin-top: 3px;
            font-weight: 500;
        }
        
        .rule-item {
            border: 1px solid #d0d0d0;
            padding: 12px;
            margin: 8px 0;
            background-color: white;
            border-radius: 3px;
            position: relative;
        }
        
        .file-item {
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #e0e0e0;
            margin: 3px 0;
            border-radius: 2px;
            background-color: white;
            display: flex;
            align-items: center;
        }
        
        .file-item:hover {
            background-color: #f0f0f0;
        }
        
        .file-item.selected {
            background-color: #e3f2fd;
            border-color: #0078d4;
        }
        
        .bullet {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .bullet.pending { background-color: #999; }
        .bullet.processing { background-color: #0078d4; }
        .bullet.processed { background-color: #107c10; }
        .bullet.error { background-color: #d13438; }
        .bullet.selected { background-color: #0078d4; }
        
        pre {
            border: 1px solid #d0d0d0;
            padding: 12px;
            background-color: white;
            overflow: auto;
            overflow-x: auto;
            max-height: 400px;
            font-size: 12px;
            font-family: 'Consolas', 'Courier New', monospace;
            border-radius: 2px;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-all;
        }
        
        h1 {
            color: #323130;
            font-size: 24px;
            font-weight: 600;
            margin: 0 0 8px 0;
        }
        
        h2 {
            color: #323130;
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 12px 0;
        }
        
        h3 {
            color: #323130;
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 8px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        h3:hover {
            color: #0078d4;
        }
        
        label {
            display: block;
            margin: 8px 0 4px 0;
            font-weight: 600;
            color: #323130;
        }
        
        .form-group {
            margin: 12px 0;
        }
        
        .profile-controls {
            background-color: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 12px;
            margin: 10px 0;
            border-radius: 3px;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        
        .file-browser {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 15px;
        }
        
        .tag-suggestions {
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 2px;
            margin-top: 5px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .tag-suggestion {
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .tag-suggestion:hover {
            background-color: #f0f0f0;
        }
        
        .tag-suggestion:last-child {
            border-bottom: none;
        }
        
        .xml-tree {
            background-color: white;
            border: 1px solid #e0e0e0;
            border-radius: 2px;
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: auto;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            word-wrap: break-word;
        }
        
        .tree-node {
            margin: 3px 0;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 2px;
            line-height: 1.4;
        }
        
        .tree-node:hover {
            background-color: #f0f0f0;
        }
        
        .tree-node.selected {
            background-color: #e3f2fd;
            border: 1px solid #0078d4;
        }
        
        .tree-expand {
            display: inline-block;
            width: 16px;
            cursor: pointer;
            color: #666;
            font-weight: bold;
            margin-right: 4px;
        }
        
        .tree-indent {
            display: inline-block;
            width: 20px;
        }
        
        .tree-tag {
            color: #0078d4;
            font-weight: 600;
        }
        
        .tree-attribute {
            color: #008000;
            font-size: 12px;
        }
        
        .tree-text {
            color: #666;
            font-size: 12px;
            font-style: italic;
        }
        
        .tree-entity {
            color: #8B4513;
            font-weight: 500;
        }
        
        .tree-path {
            color: #999;
            font-size: 11px;
            margin-left: 8px;
            word-wrap: break-word;
            word-break: break-all;
        }
        
        .targeting-mode {
            background-color: #fff9c4;
            border: 1px solid #fadb14;
            padding: 8px;
            border-radius: 3px;
            margin: 8px 0;
        }
        
        .attribute-editor {
            background-color: #f8f8f8;
            border: 1px solid #e0e0e0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        
        .collapse-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }
        
        .collapse-icon.collapsed {
            transform: rotate(90deg);
        }
        
        /* Additional overflow and text wrapping styles */
        .tree-node, .tree-tag, .tree-attribute, .tree-text {
            word-wrap: break-word;
            word-break: break-all;
            max-width: 100%;
        }
        
        textarea, input[type="text"] {
            word-wrap: break-word;
            resize: vertical;
        }
        
        @media (max-width: 768px) {
            .two-column, .file-browser, .three-column {
                grid-template-columns: 1fr;
            }
            body {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect, useRef } = React;

        // Load UI text from external files (would be loaded via fetch in production)
        const UI_TEXT = {
            buttons: {
                saveProfile: "Save Profile",
                loadProfile: "Load Profile",
                selectFiles: "Select XML File(s)",
                selectFolder: "Select Folder",
                pasteData: "Paste XML Data",
                addRule: "Add Rule",
                updateRule: "Update Rule",
                cancel: "Cancel",
                edit: "Edit",
                delete: "Delete",
                applyRules: "Apply Rules to All Files",
                processing: "Processing...",
                copyProcessed: "Copy Processed",
                copyFile: "Copy",
                original: "Original",
                modified: "Modified",
                collapse: "v",
                expand: ">"
            },
            headers: {
                profileManagement: "Profile Management",
                loadXmlFiles: "Load XML Files",
                xmlStructure: "XML Structure",
                defineNewRule: "Define New Update Rule",
                editRule: "Edit Update Rule",
                currentRules: "Current Update Rules",
                loadedFiles: "Loaded Files",
                filePreview: "File Preview",
                processingResults: "Processing & Results"
            },
            labels: {
                profileName: "Profile Name (optional)",
                targetTag: "Target Tag Name or Path",
                targetType: "Target Type",
                attributeName: "Attribute Name",
                conditionLogic: "Condition Logic",
                conditionValue: "Condition Value",
                conditionValueRegex: "Condition Value (Regex)",
                actionLogic: "Action Logic",
                searchRegex: "Search Regex (for replacement)",
                newContent: "New Content Value",
                replacementValue: "Replacement Value (can use $1, $2 etc.)"
            },
            placeholders: {
                profileName: "My XML Rules",
                targetTag: "e.g., 'title', 'data*', or 'task/equipment/status'",
                attributeName: "e.g., 'id', 'class', 'type'",
                regexPattern: "Enter Regex pattern",
                textValue: "Enter text value",
                searchRegex: "Regex to find text, e.g., 'old_text(\\d+)'",
                newContent: "Enter new content",
                replacementValue: "e.g., 'new_text$1'"
            },
            alerts: {
                noRulesToSave: "No rules to save. Please create some rules first.",
                invalidProfile: "Invalid profile format.",
                profileLoaded: (name, count) => `Profile "${name}" loaded successfully with ${count} rules.`,
                errorLoadingProfile: (error) => `Error loading profile: ${error}`,
                noFilesOrRules: "Please load XML files and define at least one update rule.",
                fileNotProcessed: "File has not been processed or processing resulted in an error.",
                noProcessedFiles: "No files were successfully processed to download.",
                xmlReadError: "Some XML files could not be read. Please check console for errors.",
                noXmlFound: "No XML files found in selection."
            },
            status: {
                viewing: (filename) => `Viewing: ${filename}`,
                ruleCount: (count) => `(${count})`,
                fileCount: (count) => `(${count})`,
                selectedPath: (path) => `Selected path: ${path} - Click "Add Rule" to use this target.`,
                noChanges: "No changes applied to this file based on current rules."
            }
        };

        // Types and Enums
        const ConditionLogic = {
            ALWAYS_APPLY: "Always Apply",
            CONTENT_EQUALS: "Content Equals",
            CONTENT_CONTAINS: "Content Contains",
            CONTENT_MATCHES_REGEX: "Content Matches Regex",
            ATTRIBUTE_EQUALS: "Attribute Equals",
            ATTRIBUTE_CONTAINS: "Attribute Contains",
            ATTRIBUTE_EXISTS: "Attribute Exists"
        };

        const ActionLogic = {
            REPLACE_ENTIRE_CONTENT: "Replace Entire Content with Text",
            REGEX_REPLACE_IN_CONTENT: "Regex Replace in Content",
            REMOVE_TAG: "Remove Tag",
            SET_ATTRIBUTE: "Set Attribute Value",
            REMOVE_ATTRIBUTE: "Remove Attribute",
            REPLACE_ENTITY: "Replace Entity"
        };

        const TargetType = {
            TAG: "Tag/Element",
            ATTRIBUTE: "Attribute",
            ENTITY: "Entity/Declaration"
        };

        // Enhanced XML Structure Analysis with attributes and entities
        const analyzeXmlStructure = (xmlString) => {
            const structure = [];
            const tagPaths = new Set();
            const entities = new Set();
            
            try {
                // Extract entities and declarations first
                const entityMatches = xmlString.match(/<!(?:ENTITY|DOCTYPE|ELEMENT|ATTLIST)[^>]*>/g) || [];
                entityMatches.forEach(entity => {
                    entities.add(entity);
                    structure.push({
                        type: 'entity',
                        tag: entity,
                        path: entity,
                        depth: 0,
                        hasChildren: false,
                        textContent: '',
                        attributes: {}
                    });
                });

                const parser = new DOMParser();
                const doc = parser.parseFromString(xmlString, "application/xml");
                
                const parsingError = doc.getElementsByTagName("parsererror");
                if (parsingError.length > 0) {
                    return { structure, tagPaths: [], entities: Array.from(entities) };
                }

                const buildPath = (element, path = [], parentExpanded = true) => {
                    const currentPath = [...path, element.tagName];
                    const pathString = currentPath.join('/');
                    tagPaths.add(pathString);
                    
                    // Get attributes
                    const attributes = {};
                    for (let i = 0; i < element.attributes.length; i++) {
                        const attr = element.attributes[i];
                        attributes[attr.name] = attr.value;
                    }

                    // Add attribute paths
                    Object.keys(attributes).forEach(attrName => {
                        tagPaths.add(`${pathString}@${attrName}`);
                    });
                    
                    structure.push({
                        type: 'element',
                        tag: element.tagName,
                        path: pathString,
                        depth: currentPath.length - 1,
                        hasChildren: element.children.length > 0,
                        textContent: element.children.length === 0 ? (element.textContent || '').trim() : '',
                        attributes: attributes,
                        expanded: parentExpanded
                    });

                    // Process all children
                    Array.from(element.children).forEach(child => {
                        buildPath(child, currentPath, parentExpanded);
                    });
                };

                if (doc.documentElement) {
                    buildPath(doc.documentElement);
                }
            } catch (e) {
                console.error("Error analyzing XML structure:", e);
            }
            
            return { 
                structure, 
                tagPaths: Array.from(tagPaths).sort(),
                entities: Array.from(entities)
            };
        };

        // Enhanced XML Processing with attributes and entities
        const applyRulesToXmlWithPath = (xmlString, rules) => {
            try {
                // Handle entity rules first
                let processedXml = xmlString;
                
                rules.forEach(rule => {
                    if (rule.targetType === TargetType.ENTITY) {
                        if (rule.actionLogic === ActionLogic.REPLACE_ENTITY) {
                            const entityRegex = new RegExp(escapeRegExp(rule.targetTag), 'g');
                            processedXml = processedXml.replace(entityRegex, rule.actionValue);
                        }
                    }
                });

                const parser = new DOMParser();
                const doc = parser.parseFromString(processedXml, "application/xml");
                const serializer = new XMLSerializer();

                const parsingError = doc.getElementsByTagName("parsererror");
                if (parsingError.length > 0) {
                    const errorText = parsingError[0]?.textContent || "Unknown parsing error";
                    console.error("XML Parsing Error:", errorText);
                    return { updatedXml: xmlString, error: `Invalid XML: ${errorText.substring(0,100)}...` };
                }

                let modified = false;

                rules.forEach(rule => {
                    if (rule.targetType === TargetType.ENTITY) return; // Already handled above
                    
                    const elementsToProcess = [];
                    
                    // Handle attribute targeting
                    if (rule.targetType === TargetType.ATTRIBUTE) {
                        const [elementPath, attributeName] = rule.targetTag.split('@');
                        const elements = findElementsByPath(doc, elementPath);
                        elements.forEach(element => {
                            if (element.hasAttribute(attributeName)) {
                                elementsToProcess.push({ element, attributeName });
                            }
                        });
                    } else {
                        // Handle element targeting (existing logic)
                        if (rule.targetTag.includes('/')) {
                            const pathParts = rule.targetTag.split('/');
                            let currentElements = [doc.documentElement];
                            
                            pathParts.forEach(part => {
                                const nextElements = [];
                                currentElements.forEach(element => {
                                    if (part.includes('*') || part.includes('?')) {
                                        const regexPattern = part
                                            .replace(/[.+^${}()|[\]\\]/g, '\\$&')
                                            .replace(/\*/g, '.*')
                                            .replace(/\?/g, '.');
                                        const tagRegex = new RegExp(`^${regexPattern}$`, 'i');
                                        
                                        Array.from(element.children).forEach(child => {
                                            if (tagRegex.test(child.tagName)) {
                                                nextElements.push(child);
                                            }
                                        });
                                    } else {
                                        Array.from(element.children).forEach(child => {
                                            if (child.tagName === part) {
                                                nextElements.push(child);
                                            }
                                        });
                                    }
                                });
                                currentElements = nextElements;
                            });
                            
                            elementsToProcess.push(...currentElements.map(el => ({ element: el })));
                        } 
                        else if (rule.targetTag.includes('*') || rule.targetTag.includes('?')) {
                            const regexPattern = rule.targetTag
                                .replace(/[.+^${}()|[\]\\]/g, '\\$&')
                                .replace(/\*/g, '.*')
                                .replace(/\?/g, '.');
                            const tagRegex = new RegExp(`^${regexPattern}$`, 'i');
                            
                            const allElements = doc.getElementsByTagName('*');
                            for (let i = 0; i < allElements.length; i++) {
                                if (tagRegex.test(allElements[i].tagName)) {
                                    elementsToProcess.push({ element: allElements[i] });
                                }
                            }
                        } 
                        else {
                            const foundElements = doc.getElementsByTagName(rule.targetTag);
                            for (let i = 0; i < foundElements.length; i++) {
                                elementsToProcess.push({ element: foundElements[i] });
                            }
                        }
                    }

                    elementsToProcess.forEach(({ element, attributeName }) => {
                        let conditionMet = false;
                        
                        // Check conditions based on type
                        if (rule.targetType === TargetType.ATTRIBUTE && attributeName) {
                            const attributeValue = element.getAttribute(attributeName) || "";
                            
                            switch (rule.conditionLogic) {
                                case ConditionLogic.ALWAYS_APPLY:
                                    conditionMet = true;
                                    break;
                                case ConditionLogic.ATTRIBUTE_EQUALS:
                                    conditionMet = attributeValue === rule.conditionValue;
                                    break;
                                case ConditionLogic.ATTRIBUTE_CONTAINS:
                                    conditionMet = attributeValue.includes(rule.conditionValue);
                                    break;
                                case ConditionLogic.ATTRIBUTE_EXISTS:
                                    conditionMet = element.hasAttribute(attributeName);
                                    break;
                                case ConditionLogic.CONTENT_MATCHES_REGEX:
                                    try {
                                        const regex = new RegExp(rule.conditionValue);
                                        conditionMet = regex.test(attributeValue);
                                    } catch (e) {
                                        console.error("Invalid regex in condition: ", rule.conditionValue, e);
                                    }
                                    break;
                            }
                        } else {
                            // Element content conditions
                            const currentContent = element.textContent || "";
                            
                            switch (rule.conditionLogic) {
                                case ConditionLogic.ALWAYS_APPLY:
                                    conditionMet = true;
                                    break;
                                case ConditionLogic.CONTENT_EQUALS:
                                    conditionMet = currentContent === rule.conditionValue;
                                    break;
                                case ConditionLogic.CONTENT_CONTAINS:
                                    conditionMet = currentContent.includes(rule.conditionValue);
                                    break;
                                case ConditionLogic.CONTENT_MATCHES_REGEX:
                                    try {
                                        const regex = new RegExp(rule.conditionValue);
                                        conditionMet = regex.test(currentContent);
                                    } catch (e) {
                                        console.error("Invalid regex in condition: ", rule.conditionValue, e);
                                    }
                                    break;
                            }
                        }

                        if (conditionMet) {
                            modified = true;
                            
                            switch (rule.actionLogic) {
                                case ActionLogic.REPLACE_ENTIRE_CONTENT:
                                    element.textContent = rule.actionValue;
                                    break;
                                case ActionLogic.REGEX_REPLACE_IN_CONTENT:
                                    if (rule.actionSearchRegex) {
                                        try {
                                            const findRegex = new RegExp(rule.actionSearchRegex, 'g');
                                            element.textContent = element.textContent.replace(findRegex, rule.actionValue);
                                        } catch (e) {
                                            console.error("Invalid regex for search/replace: ", rule.actionSearchRegex, e);
                                        }
                                    }
                                    break;
                                case ActionLogic.REMOVE_TAG:
                                    element.parentNode?.removeChild(element);
                                    break;
                                case ActionLogic.SET_ATTRIBUTE:
                                    if (attributeName) {
                                        element.setAttribute(attributeName, rule.actionValue);
                                    }
                                    break;
                                case ActionLogic.REMOVE_ATTRIBUTE:
                                    if (attributeName) {
                                        element.removeAttribute(attributeName);
                                    }
                                    break;
                            }
                        }
                    });
                });
                
                return { updatedXml: serializer.serializeToString(doc) };

            } catch (e) {
                console.error("Error applying rules to XML:", e);
                return { updatedXml: xmlString, error: e.message || "Unknown error during processing." };
            }
        };

        // Helper function to escape regex special characters
        const escapeRegExp = (string) => {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        };

        // Helper function to find elements by path
        const findElementsByPath = (doc, path) => {
            if (!path || path === '') return [doc.documentElement];
            
            const pathParts = path.split('/');
            let currentElements = [doc.documentElement];
            
            pathParts.forEach(part => {
                const nextElements = [];
                currentElements.forEach(element => {
                    Array.from(element.children).forEach(child => {
                        if (child.tagName === part) {
                            nextElements.push(child);
                        }
                    });
                });
                currentElements = nextElements;
            });
            
            return currentElements;
        };

        // Profile Management Functions
        const saveProfile = (rules, profileName) => {
            const profile = {
                name: profileName || `Profile_${new Date().toISOString().split('T')[0]}`,
                rules: rules,
                created: new Date().toISOString(),
                version: "2.0"
            };
            
            const blob = new Blob([JSON.stringify(profile, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${profile.name}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };

        const loadProfile = (file, onRulesLoaded) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const profile = JSON.parse(e.target.result);
                    if (profile.rules && Array.isArray(profile.rules)) {
                        onRulesLoaded(profile.rules);
                        alert(UI_TEXT.alerts.profileLoaded(profile.name, profile.rules.length));
                    } else {
                        alert(UI_TEXT.alerts.invalidProfile);
                    }
                } catch (error) {
                    alert(UI_TEXT.alerts.errorLoadingProfile(error.message));
                }
            };
            reader.readAsText(file);
        };

        // Auto-save to localStorage
        const autoSaveRules = (rules) => {
            try {
                localStorage.setItem('writers_best_friend_rules', JSON.stringify(rules));
            } catch (e) {
                console.warn("Could not save to localStorage:", e);
            }
        };

        const loadAutoSavedRules = () => {
            try {
                const saved = localStorage.getItem('writers_best_friend_rules');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.warn("Could not load from localStorage:", e);
                return [];
            }
        };

        // Components
        const RegexCheatSheet = () => {
            const [isExpanded, setIsExpanded] = useState(false);

            const regexPatterns = [
                { pattern: '.', description: 'Any single character' },
                { pattern: '*', description: 'Zero or more of the preceding character' },
                { pattern: '+', description: 'One or more of the preceding character' },
                { pattern: '?', description: 'Zero or one of the preceding character' },
                { pattern: '^', description: 'Start of string' },
                { pattern: '$', description: 'End of string' },
                { pattern: '\\d', description: 'Any digit (0-9)' },
                { pattern: '\\w', description: 'Any word character (a-z, A-Z, 0-9, _)' },
                { pattern: '\\s', description: 'Any whitespace character' },
                { pattern: '[abc]', description: 'Any character in the set (a, b, or c)' },
                { pattern: '[a-z]', description: 'Any lowercase letter' },
                { pattern: '[0-9]', description: 'Any digit' },
                { pattern: '(abc)', description: 'Capture group - use $1, $2, etc. in replacement' },
                { pattern: '|', description: 'OR operator (abc|def matches abc or def)' },
                { pattern: '\\', description: 'Escape special characters (\\. for literal dot)' }
            ];

            return (
                <div style={{
                    margin: '15px 0',
                    border: '1px solid #d0d0d0',
                    borderRadius: '3px',
                    backgroundColor: '#f9f9f9'
                }}>
                    <h4 
                        onClick={() => setIsExpanded(!isExpanded)}
                        style={{
                            margin: '0',
                            padding: '10px 15px',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            fontSize: '14px',
                            fontWeight: '600',
                            color: '#323130',
                            borderBottom: isExpanded ? '1px solid #d0d0d0' : 'none'
                        }}
                    >
                        <span style={{
                            transform: isExpanded ? 'rotate(90deg)' : 'rotate(0deg)',
                            transition: 'transform 0.2s'
                        }}>></span>
                        Regex Quick Reference
                    </h4>
                    
                    {isExpanded && (
                        <div style={{ padding: '15px' }}>
                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'auto 1fr',
                                gap: '8px 15px',
                                fontSize: '13px',
                                fontFamily: 'Consolas, Courier New, monospace'
                            }}>
                                {regexPatterns.map((item, index) => (
                                    <React.Fragment key={index}>
                                        <code style={{
                                            backgroundColor: '#e8e8e8',
                                            padding: '2px 6px',
                                            borderRadius: '2px',
                                            fontWeight: 'bold'
                                        }}>
                                            {item.pattern}
                                        </code>
                                        <span style={{ color: '#333' }}>{item.description}</span>
                                    </React.Fragment>
                                ))}
                            </div>
                            
                            <div style={{
                                marginTop: '12px',
                                padding: '8px',
                                backgroundColor: '#fff3cd',
                                border: '1px solid #ffeaa7',
                                borderRadius: '2px',
                                fontSize: '12px'
                            }}>
                                <strong>Examples:</strong><br/>
                                <code>\\d+</code> - One or more digits<br/>
                                <code>^[A-Z]</code> - Starts with uppercase letter<br/>
                                <code>(\\w+)-(\\d+)</code> - Captures word-dash-number (use $1-$2 in replacement)
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const XmlStructureViewer = ({ files, onPathSelect, selectedPath }) => {
            const [xmlStructure, setXmlStructure] = useState([]);
            const [tagPaths, setTagPaths] = useState([]);
            const [entities, setEntities] = useState([]);
            const [expandedNodes, setExpandedNodes] = useState(new Set());
            const [isCollapsed, setIsCollapsed] = useState(false);
            
            useEffect(() => {
                if (files.length > 0) {
                    const { structure, tagPaths: paths, entities: entityList } = analyzeXmlStructure(files[0].originalContent);
                    setXmlStructure(structure);
                    setTagPaths(paths);
                    setEntities(entityList);
                    
                    // Auto-expand first 3 levels for better visibility
                    const autoExpand = new Set();
                    structure.forEach(node => {
                        if (node.depth <= 2) {
                            autoExpand.add(node.path);
                        }
                    });
                    setExpandedNodes(autoExpand);
                }
            }, [files]);

            const toggleNode = (path) => {
                const newExpanded = new Set(expandedNodes);
                if (newExpanded.has(path)) {
                    newExpanded.delete(path);
                } else {
                    newExpanded.add(path);
                }
                setExpandedNodes(newExpanded);
            };

            const renderNode = (node, index) => {
                const isExpanded = expandedNodes.has(node.path);
                const hasChildren = node.hasChildren;
                
                if (node.type === 'entity') {
                    return (
                        <div
                            key={index}
                            className={`tree-node ${selectedPath === node.path ? 'selected' : ''}`}
                            onClick={() => onPathSelect(node.path)}
                        >
                            <span className="tree-entity">📄 {node.tag}</span>
                        </div>
                    );
                }

                return (
                    <div key={index}>
                        <div
                            className={`tree-node ${selectedPath === node.path ? 'selected' : ''}`}
                            onClick={() => onPathSelect(node.path)}
                        >
                            <span className="tree-indent" style={{width: `${node.depth * 20}px`}}></span>
                            {hasChildren && (
                                <span 
                                    className="tree-expand"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        toggleNode(node.path);
                                    }}
                                >
                                    {isExpanded ? 'v' : '>'}
                                </span>
                            )}
                            {!hasChildren && <span className="tree-expand"> </span>}
                            <span className="tree-tag">&lt;{node.tag}&gt;</span>
                            
                            {Object.keys(node.attributes).length > 0 && (
                                <span className="tree-attribute">
                                    {' '}
                                    {Object.entries(node.attributes).map(([name, value]) => (
                                        <span key={name} onClick={(e) => {
                                            e.stopPropagation();
                                            onPathSelect(`${node.path}@${name}`);
                                        }}>
                                            {name}="{value.length > 20 ? value.substring(0,20)+'...' : value}" 
                                        </span>
                                    ))}
                                </span>
                            )}
                            
                            {node.textContent && (
                                <span className="tree-text">
                                    {' "' + (node.textContent.length > 30 ? node.textContent.substring(0,30)+'...' : node.textContent) + '"'}
                                </span>
                            )}
                            
                            <span className="tree-path">{node.path}</span>
                        </div>
                        
                        {/* Render attribute nodes */}
                        {isExpanded && Object.keys(node.attributes).map(attrName => (
                            <div
                                key={`${node.path}@${attrName}`}
                                className={`tree-node ${selectedPath === `${node.path}@${attrName}` ? 'selected' : ''}`}
                                onClick={() => onPathSelect(`${node.path}@${attrName}`)}
                            >
                                <span className="tree-indent" style={{width: `${(node.depth + 1) * 20}px`}}></span>
                                <span className="tree-expand"> </span>
                                <span className="tree-attribute">@{attrName}: "{node.attributes[attrName]}"</span>
                            </div>
                        ))}
                    </div>
                );
            };

            if (files.length === 0) {
                return (
                    <div className="section">
                        <h3 onClick={() => setIsCollapsed(!isCollapsed)}>
                            <span className={`collapse-icon ${isCollapsed ? 'collapsed' : ''}`}>v</span>
                            {UI_TEXT.headers.xmlStructure}
                        </h3>
                    </div>
                );
            }

            return (
                <div className={`section ${isCollapsed ? 'collapsed' : ''}`}>
                    <h3 onClick={() => setIsCollapsed(!isCollapsed)}>
                        <span className={`collapse-icon ${isCollapsed ? 'collapsed' : ''}`}>v</span>
                        {UI_TEXT.headers.xmlStructure}
                    </h3>
                    
                    {!isCollapsed && (
                        <div className="xml-tree">
                            {entities.map((entity, index) => renderNode({
                                type: 'entity',
                                tag: entity,
                                path: entity,
                                depth: 0,
                                hasChildren: false
                            }, `entity-${index}`))}
                            
                            {xmlStructure.filter(node => node.type === 'element').map((node, index) => {
                                // Only render if parent is expanded or this is a top-level node
                                const parentPath = node.path.split('/').slice(0, -1).join('/');
                                const shouldRender = node.depth === 0 || expandedNodes.has(parentPath);
                                
                                return shouldRender ? renderNode(node, index) : null;
                            })}
                        </div>
                    )}
                </div>
            );
        };

        const ProfileManager = ({ rules, onRulesLoaded }) => {
            const [profileName, setProfileName] = useState('');
            const fileInputRef = useRef(null);

            const handleSaveProfile = () => {
                if (rules.length === 0) {
                    alert(UI_TEXT.alerts.noRulesToSave);
                    return;
                }
                saveProfile(rules, profileName || undefined);
                setProfileName('');
            };

            const handleLoadProfile = (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadProfile(file, onRulesLoaded);
                }
                event.target.value = '';
            };

            return (
                <div className="profile-controls">
                    <h3>{UI_TEXT.headers.profileManagement}</h3>
                    <div style={{display: 'flex', gap: '10px', alignItems: 'end', flexWrap: 'wrap'}}>
                        <div style={{flex: '1', minWidth: '200px'}}>
                            <label>{UI_TEXT.labels.profileName}</label>
                            <input
                                type="text"
                                value={profileName}
                                onChange={(e) => setProfileName(e.target.value)}
                                placeholder={UI_TEXT.placeholders.profileName}
                            />
                        </div>
                        <button onClick={handleSaveProfile} className="primary">
                            {UI_TEXT.buttons.saveProfile}
                        </button>
                        <button onClick={() => fileInputRef.current?.click()}>
                            {UI_TEXT.buttons.loadProfile}
                        </button>
                        <input
                            type="file"
                            ref={fileInputRef}
                            accept=".json"
                            onChange={handleLoadProfile}
                            style={{display: 'none'}}
                        />
                    </div>
                </div>
            );
        };

        const FileSelector = ({ onFilesSelected, isLoading }) => {
            const fileInputRef = useRef(null);
            const folderInputRef = useRef(null);
            const [pastedData, setPastedData] = useState('');
            const [showPasteArea, setShowPasteArea] = useState(false);

            const handleFileProcessing = useCallback(async (selectedFiles) => {
                if (!selectedFiles || selectedFiles.length === 0) return;

                const xmlFilesPromises = Array.from(selectedFiles)
                    .filter(file => file.name.toLowerCase().endsWith('.xml'))
                    .map(file => {
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                if (e.target?.result) {
                                    resolve({
                                        id: crypto.randomUUID(),
                                        name: file.name,
                                        originalContent: e.target.result,
                                        modifiedContent: null,
                                        status: 'pending',
                                    });
                                } else {
                                    resolve(null);
                                }
                            };
                            reader.onerror = (e) => {
                                console.error("File reading error:", file.name, e);
                                resolve(null);
                            };
                            reader.readAsText(file);
                        });
                    });

                const loadedFiles = (await Promise.all(xmlFilesPromises)).filter(f => f !== null);
                if (loadedFiles.length > 0) {
                    onFilesSelected(loadedFiles);
                } else if (Array.from(selectedFiles).some(f => f.name.toLowerCase().endsWith('.xml'))) {
                    alert(UI_TEXT.alerts.xmlReadError);
                } else if (selectedFiles.length > 0) {
                    alert(UI_TEXT.alerts.noXmlFound);
                }
            }, [onFilesSelected]);

            const handleFileChange = (event) => {
                handleFileProcessing(event.target.files);
                if (event.target) event.target.value = '';
            };

            const openFileDialog = () => fileInputRef.current?.click();
            const openFolderDialog = () => folderInputRef.current?.click();

            const handlePasteData = () => {
                if (!pastedData.trim()) {
                    alert("Please paste XML data first.");
                    return;
                }
                
                const xmlFile = {
                    id: crypto.randomUUID(),
                    name: `Pasted_Data_${new Date().toISOString().split('T')[0]}.xml`,
                    originalContent: pastedData,
                    modifiedContent: null,
                    status: 'pending',
                };
                
                onFilesSelected([xmlFile]);
                setPastedData('');
                setShowPasteArea(false);
            };

            return (
                <div className="section">
                    <h2>{UI_TEXT.headers.loadXmlFiles}</h2>
                    <div style={{display: 'flex', gap: '10px', flexWrap: 'wrap', marginBottom: '15px'}}>
                        <button onClick={openFileDialog} disabled={isLoading} className="primary">
                            {UI_TEXT.buttons.selectFiles}
                        </button>
                        <button onClick={openFolderDialog} disabled={isLoading}>
                            {UI_TEXT.buttons.selectFolder}
                        </button>
                        <button onClick={() => setShowPasteArea(!showPasteArea)} disabled={isLoading}>
                            {UI_TEXT.buttons.pasteData}
                        </button>
                        <input
                            type="file"
                            ref={fileInputRef}
                            multiple
                            accept=".xml,application/xml,text/xml"
                            onChange={handleFileChange}
                            style={{display: 'none'}}
                        />
                        <input
                            type="file"
                            ref={folderInputRef}
                            webkitdirectory=""
                            directory=""
                            multiple
                            onChange={handleFileChange}
                            style={{display: 'none'}}
                        />
                    </div>
                    {showPasteArea && (
                        <div style={{marginBottom: '15px'}}>
                            <textarea
                                value={pastedData}
                                onChange={(e) => setPastedData(e.target.value)}
                                placeholder="Paste your XML data here..."
                                rows={8}
                                style={{width: '100%', fontFamily: 'monospace', fontSize: '14px'}}
                            />
                            <div style={{marginTop: '10px', display: 'flex', gap: '10px'}}>
                                <button onClick={handlePasteData} className="primary" disabled={!pastedData.trim()}>
                                    Load Pasted Data
                                </button>
                                <button onClick={() => {setPastedData(''); setShowPasteArea(false);}}>
                                    Cancel
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const TagSuggestions = ({ tags, onTagSelect, visible }) => {
            if (!visible || tags.length === 0) return null;

            return (
                <div className="tag-suggestions">
                    {tags.map(tag => (
                        <div
                            key={tag}
                            className="tag-suggestion"
                            onClick={() => onTagSelect(tag)}
                        >
                            {tag}
                        </div>
                    ))}
                </div>
            );
        };

        const RuleEditor = ({ onAddRule, existingRule, onUpdateRule, onCancelEdit, discoveredTags, tagPaths, selectedPath, onPathSelect }) => {
            const initialRuleState = {
                targetTag: '',
                targetType: TargetType.ATTRIBUTE,
                attributeName: '',
                conditionLogic: ConditionLogic.ATTRIBUTE_CONTAINS,
                conditionValue: '',
                actionLogic: ActionLogic.REPLACE_ENTIRE_CONTENT,
                actionValue: '',
                actionSearchRegex: '',
            };

            const [rule, setRule] = useState(existingRule || initialRuleState);
            const [errors, setErrors] = useState({});
            const [showTagSuggestions, setShowTagSuggestions] = useState(false);

            const conditionLogicOptions = Object.values(ConditionLogic).map(val => ({ value: val, label: val }));
            const actionLogicOptions = Object.values(ActionLogic).map(val => ({ value: val, label: val }));
            const targetTypeOptions = Object.values(TargetType).map(val => ({ value: val, label: val }));

            useEffect(() => {
                if (existingRule) {
                    setRule(existingRule);
                    setErrors({});
                } else {
                    setRule(initialRuleState);
                    setErrors({});
                }
            }, [existingRule]);

            useEffect(() => {
                if (selectedPath) {
                    if (selectedPath.includes('@')) {
                        const [path, attr] = selectedPath.split('@');
                        handleInputChange('targetTag', path);
                        handleInputChange('attributeName', attr);
                        handleInputChange('targetType', TargetType.ATTRIBUTE);
                    } else if (selectedPath.startsWith('<!')) {
                        handleInputChange('targetTag', selectedPath);
                        handleInputChange('targetType', TargetType.ENTITY);
                    } else {
                        handleInputChange('targetTag', selectedPath);
                        handleInputChange('targetType', TargetType.ATTRIBUTE);
                        handleInputChange('conditionLogic', ConditionLogic.ATTRIBUTE_CONTAINS);
                    }
                    onPathSelect(null);
                }
            }, [selectedPath]);

            const validateRule = () => {
                const newErrors = {};
                if (!rule.targetTag.trim()) newErrors.targetTag = "Target tag is required.";
                
                if (rule.targetType === TargetType.ATTRIBUTE && !rule.attributeName.trim()) {
                    newErrors.attributeName = "Attribute name is required.";
                }
                
                if (rule.conditionLogic !== ConditionLogic.ALWAYS_APPLY && 
                    rule.conditionLogic !== ConditionLogic.ATTRIBUTE_EXISTS && 
                    !rule.conditionValue.trim()) {
                    newErrors.conditionValue = "Condition value is required for the selected logic.";
                }
                
                if (rule.conditionLogic === ConditionLogic.CONTENT_MATCHES_REGEX && rule.conditionValue) {
                    try { new RegExp(rule.conditionValue); } 
                    catch (e) { newErrors.conditionValue = "Invalid Regex pattern for condition."; }
                }

                if (rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT) {
                    if (!rule.actionSearchRegex?.trim()) newErrors.actionSearchRegex = "Search Regex is required for this action.";
                    else {
                        try { new RegExp(rule.actionSearchRegex); }
                        catch (e) { newErrors.actionSearchRegex = "Invalid Regex pattern for search."; }
                    }
                }
                setErrors(newErrors);
                return Object.keys(newErrors).length === 0;
            };

            const handleSubmit = (event) => {
                event.preventDefault();
                if (!validateRule()) return;
                
                const finalRule = { ...rule, id: existingRule?.id || crypto.randomUUID() };

                if (existingRule && onUpdateRule) {
                    onUpdateRule(finalRule);
                } else {
                    onAddRule(finalRule);
                    setRule(initialRuleState);
                    setErrors({});
                }
            };

            const handleInputChange = (field, value) => {
                setRule(prev => ({ ...prev, [field]: value }));
                if (errors[field]) {
                    setErrors(prev => ({ ...prev, [field]: undefined }));
                }
            };

            const handleTagSelect = (tag) => {
                if (tag.includes('@')) {
                    const [path, attr] = tag.split('@');
                    handleInputChange('targetTag', path);
                    handleInputChange('attributeName', attr);
                    handleInputChange('targetType', TargetType.ATTRIBUTE);
                } else if (tag.startsWith('<!')) {
                    handleInputChange('targetTag', tag);
                    handleInputChange('targetType', TargetType.ENTITY);
                } else {
                    handleInputChange('targetTag', tag);
                    handleInputChange('targetType', TargetType.TAG);
                }
                setShowTagSuggestions(false);
            };

            const allSuggestions = [...new Set([...discoveredTags, ...tagPaths])].sort();
            
            return (
                <form onSubmit={handleSubmit} className="section">
                    <h2>{existingRule ? UI_TEXT.headers.editRule : UI_TEXT.headers.defineNewRule}</h2>
                    
                    {selectedPath && (
                        <div className="targeting-mode">
                            <strong>{UI_TEXT.status.selectedPath(selectedPath)}</strong>
                        </div>
                    )}
                    
                    <div className="form-group">
                        <label htmlFor="targetType">{UI_TEXT.labels.targetType}</label>
                        <select
                            id="targetType"
                            value={rule.targetType}
                            onChange={(e) => handleInputChange('targetType', e.target.value)}
                        >
                            {targetTypeOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                        </select>
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="targetTag">
                            {rule.targetType === TargetType.ENTITY ? 'Entity/Declaration' : 
                             rule.targetType === TargetType.ATTRIBUTE ? 'Element Path' : 
                             UI_TEXT.labels.targetTag}
                        </label>
                        <input
                            type="text"
                            id="targetTag"
                            value={rule.targetTag}
                            onChange={(e) => handleInputChange('targetTag', e.target.value)}
                            onFocus={() => setShowTagSuggestions(true)}
                            onBlur={() => setTimeout(() => setShowTagSuggestions(false), 200)}
                            placeholder={
                                rule.targetType === TargetType.ENTITY ? "e.g., '<!DOCTYPE html>', '<!ENTITY name \"value\">' " :
                                UI_TEXT.placeholders.targetTag
                            }
                        />
                        <TagSuggestions 
                            tags={allSuggestions} 
                            onTagSelect={handleTagSelect}
                            visible={showTagSuggestions && allSuggestions.length > 0}
                        />
                        {errors.targetTag && <div className="error">{errors.targetTag}</div>}
                    </div>

                    {rule.targetType === TargetType.ATTRIBUTE && (
                        <div className="form-group">
                            <label htmlFor="attributeName">{UI_TEXT.labels.attributeName}</label>
                            <input
                                type="text"
                                id="attributeName"
                                value={rule.attributeName}
                                onChange={(e) => handleInputChange('attributeName', e.target.value)}
                                placeholder={UI_TEXT.placeholders.attributeName}
                            />
                            {errors.attributeName && <div className="error">{errors.attributeName}</div>}
                        </div>
                    )}

                    <div className="two-column">
                        <div className="form-group">
                            <label htmlFor="conditionLogic">{UI_TEXT.labels.conditionLogic}</label>
                            <select
                                id="conditionLogic"
                                value={rule.conditionLogic}
                                onChange={(e) => handleInputChange('conditionLogic', e.target.value)}
                            >
                                {conditionLogicOptions.map(opt => {
                                    // Filter options based on target type
                                    if (rule.targetType === TargetType.ATTRIBUTE) {
                                        if (opt.value.startsWith('CONTENT_')) return null;
                                    } else if (rule.targetType === TargetType.ENTITY) {
                                        if (opt.value.startsWith('ATTRIBUTE_')) return null;
                                    } else {
                                        if (opt.value.startsWith('ATTRIBUTE_')) return null;
                                    }
                                    return <option key={opt.value} value={opt.value}>{opt.label}</option>;
                                })}
                            </select>
                        </div>
                        {rule.conditionLogic !== ConditionLogic.ALWAYS_APPLY && 
                         rule.conditionLogic !== ConditionLogic.ATTRIBUTE_EXISTS && (
                            <div className="form-group">
                                <label htmlFor="conditionValue">
                                    {UI_TEXT.labels.conditionValue} {rule.conditionLogic === ConditionLogic.CONTENT_MATCHES_REGEX && "(Regex)"}
                                </label>
                                <input
                                    type="text"
                                    id="conditionValue"
                                    value={rule.conditionValue}
                                    onChange={(e) => handleInputChange('conditionValue', e.target.value)}
                                    placeholder={
                                        rule.conditionLogic === ConditionLogic.CONTENT_MATCHES_REGEX ? UI_TEXT.placeholders.regexPattern : UI_TEXT.placeholders.textValue
                                    }
                                />
                                {errors.conditionValue && <div className="error">{errors.conditionValue}</div>}
                            </div>
                        )}
                    </div>
                    
                    <div className="form-group">
                        <label htmlFor="actionLogic">{UI_TEXT.labels.actionLogic}</label>
                        <select
                            id="actionLogic"
                            value={rule.actionLogic}
                            onChange={(e) => {
                                const newActionLogic = e.target.value;
                                handleInputChange('actionLogic', newActionLogic);
                                if (newActionLogic !== ActionLogic.REGEX_REPLACE_IN_CONTENT) {
                                    handleInputChange('actionSearchRegex', '');
                                }
                            }}
                        >
                            {actionLogicOptions.map(opt => {
                                // Filter options based on target type
                                if (rule.targetType === TargetType.ATTRIBUTE) {
                                    if (opt.value === ActionLogic.REPLACE_ENTIRE_CONTENT || 
                                        opt.value === ActionLogic.REGEX_REPLACE_IN_CONTENT ||
                                        opt.value === ActionLogic.REMOVE_TAG) return null;
                                } else if (rule.targetType === TargetType.ENTITY) {
                                    if (opt.value !== ActionLogic.REPLACE_ENTITY) return null;
                                } else {
                                    if (opt.value === ActionLogic.SET_ATTRIBUTE || 
                                        opt.value === ActionLogic.REMOVE_ATTRIBUTE ||
                                        opt.value === ActionLogic.REPLACE_ENTITY) return null;
                                }
                                return <option key={opt.value} value={opt.value}>{opt.label}</option>;
                            })}
                        </select>
                    </div>

                    {rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT && (
                        <div className="form-group">
                            <label htmlFor="actionSearchRegex">{UI_TEXT.labels.searchRegex}</label>
                            <input
                                type="text"
                                id="actionSearchRegex"
                                value={rule.actionSearchRegex || ''}
                                onChange={(e) => handleInputChange('actionSearchRegex', e.target.value)}
                                placeholder={UI_TEXT.placeholders.searchRegex}
                            />
                            {errors.actionSearchRegex && <div className="error">{errors.actionSearchRegex}</div>}
                        </div>
                    )}

                    {rule.actionLogic !== ActionLogic.REMOVE_TAG && 
                     rule.actionLogic !== ActionLogic.REMOVE_ATTRIBUTE && (
                        <div className="form-group">
                            <label htmlFor="actionValue">
                                {rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT ? UI_TEXT.labels.replacementValue : 
                                 rule.actionLogic === ActionLogic.SET_ATTRIBUTE ? "Attribute Value" :
                                 rule.actionLogic === ActionLogic.REPLACE_ENTITY ? "New Entity/Declaration" :
                                 UI_TEXT.labels.newContent}
                            </label>
                            <textarea
                                id="actionValue"
                                value={rule.actionValue}
                                onChange={(e) => handleInputChange('actionValue', e.target.value)}
                                rows={rule.targetType === TargetType.ENTITY ? 4 : 3}
                                placeholder={
                                    rule.actionLogic === ActionLogic.REGEX_REPLACE_IN_CONTENT ? UI_TEXT.placeholders.replacementValue : 
                                    rule.actionLogic === ActionLogic.REPLACE_ENTITY ? "e.g., '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\">' " :
                                    UI_TEXT.placeholders.newContent
                                }
                            />
                        </div>
                    )}

                    {/* Regex Cheat Sheet */}
                    <RegexCheatSheet />

                    <div style={{marginTop: '15px', display: 'flex', gap: '8px'}}>
                        {existingRule && onCancelEdit && (
                            <button type="button" onClick={() => {
                                onCancelEdit();
                                setRule(initialRuleState);
                                setErrors({});
                            }}>
                                {UI_TEXT.buttons.cancel}
                            </button>
                        )}
                        <button type="submit" className="primary">
                            {existingRule ? UI_TEXT.buttons.updateRule : UI_TEXT.buttons.addRule}
                        </button>
                    </div>
                </form>
            );
        };

        const RuleList = ({ rules, onDeleteRule, onEditRule }) => {
            if (rules.length === 0) {
                return (
                    <div className="section">
                        <h2>{UI_TEXT.headers.currentRules}</h2>
                    </div>
                );
            }

            return (
                <div className="section">
                    <h2>{UI_TEXT.headers.currentRules} {UI_TEXT.status.ruleCount(rules.length)}</h2>
                    <div style={{maxHeight: '400px', overflow: 'auto'}}>
                        {rules.map((rule, index) => (
                            <div key={rule.id} className="rule-item">
                                <div style={{display: 'flex', alignItems: 'flex-start'}}>
                                    <div className="bullet selected"></div>
                                    <div style={{flex: 1}}>
                                        <div style={{fontWeight: '600', marginBottom: '6px'}}>
                                            Rule #{index + 1}: {rule.targetType === TargetType.ENTITY ? 'Entity' : 
                                                              rule.targetType === TargetType.ATTRIBUTE ? `Attribute @${rule.attributeName}` : 'Element'} 
                                            {rule.targetType === TargetType.ATTRIBUTE ? ` in ${rule.targetTag}` :
                                             rule.targetType === TargetType.ENTITY ? ` ${rule.targetTag.substring(0,30)}...` :
                                             rule.targetTag.includes('/') ? ` path "${rule.targetTag}"` : ` <${rule.targetTag}>`}
                                        </div>
                                        <div style={{fontSize: '12px', marginBottom: '4px', color: '#666'}}>
                                            <strong>Condition:</strong> {rule.conditionLogic} 
                                            {rule.conditionLogic !== 'Always Apply' && rule.conditionLogic !== 'Attribute Exists' && rule.conditionValue && 
                                                <span> "{rule.conditionValue.length > 30 ? rule.conditionValue.substring(0,27)+'...' : rule.conditionValue}"</span>}
                                        </div>
                                        <div style={{fontSize: '12px', color: '#666'}}>
                                            <strong>Action:</strong> {rule.actionLogic}
                                            {rule.actionLogic !== 'Remove Tag' && rule.actionLogic !== 'Remove Attribute' && 
                                                <span> "{rule.actionValue.length > 30 ? rule.actionValue.substring(0,27)+'...' : rule.actionValue}"</span>}
                                            {rule.actionLogic === 'Regex Replace in Content' && rule.actionSearchRegex && 
                                                <span> (Find: "{rule.actionSearchRegex.length > 20 ? rule.actionSearchRegex.substring(0,17)+'...' : rule.actionSearchRegex}")</span>}
                                        </div>
                                    </div>
                                    <div style={{display: 'flex', gap: '4px', marginLeft: '8px'}}>
                                        <button onClick={() => onEditRule(rule)} style={{fontSize: '11px', padding: '4px 8px'}}>
                                            {UI_TEXT.buttons.edit}
                                        </button>
                                        <button onClick={() => onDeleteRule(rule.id)} className="danger" style={{fontSize: '11px', padding: '4px 8px'}}>
                                            {UI_TEXT.buttons.delete}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const XmlFileView = ({ files, onFileSelect, selectedFileId, onCopyFile }) => {
            const [showOriginal, setShowOriginal] = useState(true);
            const selectedFile = files.find(f => f.id === selectedFileId);

            useEffect(() => {
                if (!selectedFileId || (selectedFile && !selectedFile.modifiedContent)) {
                    setShowOriginal(true);
                }
            }, [selectedFileId, selectedFile]);

            if (files.length === 0) {
                return (
                    <div className="section">
                        <h3>{UI_TEXT.headers.filePreview}</h3>
                    </div>
                );
            }

            return (
                <div className="file-browser">
                    <div className="section">
                        <h3>{UI_TEXT.headers.loadedFiles} {UI_TEXT.status.fileCount(files.length)}</h3>
                        <div style={{maxHeight: '400px', overflow: 'auto'}}>
                            {files.map(file => (
                                <div key={file.id}>
                                    <div
                                        className={`file-item ${selectedFileId === file.id ? 'selected' : ''}`}
                                        style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}
                                    >
                                        <div 
                                            onClick={() => onFileSelect(file.id)}
                                            style={{display: 'flex', alignItems: 'center', flex: 1, cursor: 'pointer'}}
                                        >
                                            <div className={`bullet ${selectedFileId === file.id ? 'selected' : file.status}`}></div>
                                            <span style={{overflow: 'hidden', textOverflow: 'ellipsis', fontSize: '15px'}}>{file.name}</span>
                                        </div>
                                        {file.status === 'processed' && file.modifiedContent && !file.error && (
                                            <button 
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    onCopyFile(file);
                                                }}
                                                style={{fontSize: '12px', padding: '4px 8px', marginLeft: '8px'}}
                                            >
                                                {UI_TEXT.buttons.copyFile}
                                            </button>
                                        )}
                                    </div>
                                    {file.status === 'error' && file.error && (
                                        <div className="error" style={{marginLeft: '20px', fontSize: '12px'}}>{file.error}</div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="section">
                        <h3>{UI_TEXT.headers.filePreview}</h3>
                        {selectedFile ? (
                            <div>
                                <div style={{marginBottom: '12px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '8px'}}>
                                    <span style={{fontWeight: '600'}}>{UI_TEXT.status.viewing(selectedFile.name)}</span>
                                    {selectedFile.modifiedContent && selectedFile.status === 'processed' && (
                                        <div style={{display: 'flex', gap: '4px'}}>
                                            <button
                                                onClick={() => setShowOriginal(true)}
                                                className={showOriginal ? 'primary' : ''}
                                                style={{fontSize: '12px', padding: '4px 8px'}}
                                            >
                                                {UI_TEXT.buttons.original}
                                            </button>
                                            <button
                                                onClick={() => setShowOriginal(false)}
                                                className={!showOriginal ? 'primary' : ''}
                                                style={{fontSize: '12px', padding: '4px 8px'}}
                                            >
                                                {UI_TEXT.buttons.modified}
                                            </button>
                                        </div>
                                    )}
                                </div>
                                <pre>
                                    {showOriginal || !selectedFile.modifiedContent ? selectedFile.originalContent : selectedFile.modifiedContent}
                                </pre>
                                {selectedFile.status === 'error' && selectedFile.error && (
                                    <div className="error" style={{marginTop: '8px', padding: '8px', backgroundColor: '#fff2f0', border: '1px solid #ffccc7'}}>{selectedFile.error}</div>
                                )}
                                {selectedFile.status === 'processed' && !selectedFile.error && selectedFile.modifiedContent === selectedFile.originalContent && (
                                    <div style={{padding: '8px', backgroundColor: '#fffbe6', border: '1px solid #ffe58f', marginTop: '8px', fontSize: '12px'}}>
                                        {UI_TEXT.status.noChanges}
                                    </div>
                                )}
                            </div>
                        ) : (
                            <p></p>
                        )}
                    </div>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [files, setFiles] = useState([]);
            const [rules, setRules] = useState(() => loadAutoSavedRules());
            const [editingRule, setEditingRule] = useState(null);
            const [selectedFileId, setSelectedFileId] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [discoveredTags, setDiscoveredTags] = useState([]);
            const [tagPaths, setTagPaths] = useState([]);
            const [selectedPath, setSelectedPath] = useState(null);

            useEffect(() => {
                autoSaveRules(rules);
            }, [rules]);

            const handleFilesSelected = useCallback((newFiles) => {
                setFiles(prevFiles => {
                    const existingFileNames = new Set(prevFiles.map(f => f.name));
                    const uniqueNewFiles = newFiles.filter(nf => !existingFileNames.has(nf.name));
                    const updatedFiles = [...prevFiles, ...uniqueNewFiles];
                    
                    const newTags = new Set(discoveredTags);
                    const newPaths = new Set(tagPaths);
                    
                    uniqueNewFiles.forEach(file => {
                        const { structure, tagPaths: paths } = analyzeXmlStructure(file.originalContent);
                        structure.forEach(node => {
                            if (node.type === 'element') {
                                newTags.add(node.tag);
                            }
                        });
                        paths.forEach(path => newPaths.add(path));
                    });
                    
                    setDiscoveredTags(Array.from(newTags).sort());
                    setTagPaths(Array.from(newPaths).sort());

                    return updatedFiles;
                });
                if (newFiles.length > 0 && !selectedFileId) {
                    setSelectedFileId(newFiles[0].id);
                }
            }, [selectedFileId, discoveredTags, tagPaths]);

            const handleAddRule = useCallback((newRule) => {
                setRules(prevRules => [...prevRules, newRule]);
            }, []);

            const handleUpdateRule = useCallback((updatedRule) => {
                setRules(prevRules => prevRules.map(r => r.id === updatedRule.id ? updatedRule : r));
                setEditingRule(null);
            }, []);

            const handleDeleteRule = useCallback((ruleId) => {
                setRules(prevRules => prevRules.filter(rule => rule.id !== ruleId));
                if (editingRule?.id === ruleId) setEditingRule(null);
            }, [editingRule]);

            const handleEditRule = (rule) => {
                setEditingRule(rule);
            };
            
            const handleCancelEditRule = () => {
                setEditingRule(null);
            };

            const handleRulesLoaded = (loadedRules) => {
                setRules(loadedRules);
                setEditingRule(null);
            };

            const processFiles = useCallback(async () => {
                if (files.length === 0 || rules.length === 0) {
                    alert(UI_TEXT.alerts.noFilesOrRules);
                    return;
                }
                setIsLoading(true);
                
                setFiles(prevFiles => prevFiles.map(f => ({ ...f, status: 'processing', error: null, modifiedContent: null })));

                const updatedFilesPromises = files.map(async (file) => {
                    await new Promise(resolve => setTimeout(resolve, 10)); 
                    const { updatedXml, error } = applyRulesToXmlWithPath(file.originalContent, rules);
                    return {
                        ...file,
                        modifiedContent: error ? file.originalContent : updatedXml,
                        status: error ? 'error' : 'processed',
                        error: error || null,
                    };
                });

                const processedFiles = await Promise.all(updatedFilesPromises);
                setFiles(processedFiles);
                setIsLoading(false);
            }, [files, rules]);

            const copyToClipboard = async (text) => {
                try {
                    await navigator.clipboard.writeText(text);
                    return true;
                } catch (err) {
                    console.error('Failed to copy: ', err);
                    return false;
                }
            };

            const copyFile = async (file) => {
                if (!file.modifiedContent) {
                    alert(UI_TEXT.alerts.fileNotProcessed);
                    return;
                }
                
                const success = await copyToClipboard(file.modifiedContent);
                if (success) {
                    alert(`Copied ${file.name} to clipboard!`);
                } else {
                    alert("Failed to copy to clipboard. Please try again.");
                }
            };
            
            const copyAllProcessedFiles = async () => {
                const successfullyProcessedFiles = files.filter(f => f.status === 'processed' && f.modifiedContent && !f.error);
                if (successfullyProcessedFiles.length === 0) {
                    alert(UI_TEXT.alerts.noProcessedFiles);
                    return;
                }
                
                const allContent = successfullyProcessedFiles.map(file => 
                    `<!-- ${file.name} -->\n${file.modifiedContent}`
                ).join('\n\n');
                
                const success = await copyToClipboard(allContent);
                if (success) {
                    alert(`Copied ${successfullyProcessedFiles.length} processed files to clipboard!`);
                } else {
                    alert("Failed to copy to clipboard. Please try again.");
                }
            };

            return (
                <div className="container">
                    <ProfileManager rules={rules} onRulesLoaded={handleRulesLoaded} />

                    <FileSelector onFilesSelected={handleFilesSelected} isLoading={isLoading} />

                    <div className="three-column">
                        <XmlStructureViewer 
                            files={files} 
                            onPathSelect={setSelectedPath}
                            selectedPath={selectedPath}
                        />
                        <RuleEditor 
                            onAddRule={handleAddRule} 
                            existingRule={editingRule}
                            onUpdateRule={handleUpdateRule}
                            onCancelEdit={handleCancelEditRule}
                            discoveredTags={discoveredTags}
                            tagPaths={tagPaths}
                            selectedPath={selectedPath}
                            onPathSelect={setSelectedPath}
                        />
                        <RuleList rules={rules} onDeleteRule={handleDeleteRule} onEditRule={handleEditRule} />
                    </div>
                    
                    {files.length > 0 && (
                        <div className="section">
                            <div style={{marginBottom: '15px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '10px'}}>
                                <h2>{UI_TEXT.headers.processingResults}</h2>
                                <div style={{display: 'flex', gap: '8px'}}>
                                    <button
                                        onClick={processFiles}
                                        disabled={isLoading || files.length === 0 || rules.length === 0}
                                        className="primary"
                                    >
                                        {isLoading ? UI_TEXT.buttons.processing : UI_TEXT.buttons.applyRules}
                                    </button>
                                    <button
                                        onClick={copyAllProcessedFiles}
                                        disabled={isLoading || files.filter(f => f.status === 'processed' && !f.error).length === 0}
                                    >
                                        {UI_TEXT.buttons.copyProcessed}
                                    </button>
                                </div>
                            </div>
                            <XmlFileView files={files} onFileSelect={setSelectedFileId} selectedFileId={selectedFileId} onCopyFile={copyFile} />
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
